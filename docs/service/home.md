# 分布式与微服务

## CAP 理论
在一个分布式系统中，一致性、可用性、分区容错性最多只能同时实现两点，不可能三者兼顾。

* **Consistency**【一致性】：指不同节点读写数据得到一致结果，比如 A 节点写一个数据，要同步到 B 节点，B 节点读时读出与 A 节点一致的结果；

* **Availability**【可用性】：只要收到用户请求，服务器必须给出回应；

* **Partition tolerance**【分区容错性】：指节点（分布式节点叫区）间通信失败；由于可能出现的不可抗因素，分区容错几乎不可避免，所以 CPA 理论一般指一致性和可用性不能同时满足；

### 为什么一致性和可用性不能同时满足？
由于通讯可能失败（分区容错），如果要满足一致性，写入的时候必须锁定其他节点，锁定区间不满足可用性；要满足可用性就不能锁定，就不满足一致性。

### 一致性与可用性如何取舍？
当数据不是特别强调一致性时，优先满足可用性，实现最终一致性即可，比如大部分普通的展示数据；当数据很重要，必须强一致时，比如涉及金额，则优先满足一致性，可用性通过友好错误提示。

## BASE 理论
即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。

* **Basically Available**【基本可用】：响应时间变长但仍能响应；部分功能异常不影响其他功能的时候用，引导到降级页面；

* **Soft State**【软状态】：允许多个节点数据短暂不一致存在延迟；

* **Eventually Consistent**【最终一致性】

## 一致性算法

### 分布式系统一致性有哪些？

1. **强一致性**（strong consistency）：任何时刻任何用户或节点都可以读到最近一次成功更新的副本数据。强一致性是程度最高的一致性要求，也是实践中最难以实现的一致性。

1. **单调一致性**（monotonic consistency）：任何时刻，任何用户一旦读到某个数据在某次更新后的值，这个用户不会再读到比这个值更旧的值。单调一致性是弱于强一致性却非常实用的一种一致性级别。因为通常来说，用户只关心从己方视角观察到的一致性，而不会关注其他用户的一致性情况。

1. **会话一致性**（session consistency）：任何用户在某一次会话内一旦读到某个数据在某次更新后的值，这个用户在这次会话过程中不会再读到比这个值更旧的值。会话一致性通过引入会话的概念，在单调一致性的基础上进一步放松约束，会话一致性只保证单个用户单次会话内数据的单调修改，对于不同用户间的一致性和同一用户不同会话间的一致性没有保障。实践中有许多机制正好对应会话的概念。

1. **最终一致性**（eventual consistency）：最终一致性要求一旦更新成功，各个副本上的数据最终将达到完全一致的状态，但达到完全一致状态所需要的时间不能保障。对于最终一致性系统而言，一个用户只要始终读取某一个副本的数据，则可以实现类似单调一致性的效果，但一旦用户更换读取的副本，则无法保障任何一致性。

1. **弱一致性**（week consistency）：一旦某个更新成功，用户无法在一个确定时间内读到这次更新的值，且即使在某个副本上读到了新的值，也不能保证在其他副本上可以读到新的值。弱一致性系统一般很难在实际中使用，使用弱一致性系统需要应用方做更多的工作从而使得系统可用。

### 分布式系统中有哪些常见的一致性算法？

1. **一致性 Hash 算法**：一致性 Hash 算法是个经典算法，Hash 环的引入是为解决单调性（Monotonicity）的问题；虚拟节点的引入是为了解决平衡性（Balance）问题。

1. **Paxos 算法**：Paxos 算法是 Lamport 宗师提出的一种基于消息传递的分布式一致性算法，使其获得 2013 年图灵奖。自 Paxos 问世以来就持续垄断了分布式一致性算法，Paxos 这个名词几乎等同于分布式一致性, 很多分布式一致性算法都由 Paxos 演变而来。

1. **Raft 算法**：Paxos是出了名的难懂，而 Raft 正是为了探索一种更易于理解的一致性算法而产生的。它的首要设计目的就是易于理解，所以在选主的冲突处理等方式上它都选择了非常简单明了的解决方案

1. **ZAB 算法**：ZAB 协议全称：Zookeeper Atomic Broadcast（Zookeeper 原子广播协议）, 它应该是所有一致性协议中生产环境中应用最多的了。为什么呢？因为他是为 Zookeeper 设计的分布式一致性协议！

### 什么是一致性 hash 算法？

普通 hash 算法选取节点**好处**是：每次相同的请求会落在相同的机器上，提高了命中率。**问题**是增删机器时会导致原有映射失效，如果是存储需要迁移数据，如果是缓存需要重新生成缓存。

一致性 hash 算法通过哈希环和虚拟节点解决了这个问题。

**实现原理**：
1. 把节点通过哈希取模后分散到 0 ~ 2 的 32 次方范围（范围不是固定的）里，将这个范围收尾相连，形成一个**哈希环**。

1. 将需要存入的数据按同样的方式计算哈希环上的位置，顺时针找到最近的节点哈希值，即找到存入的节点。

1. 当有一台机器宕机或下线时，顺时针会找到下一个节点，这样就只有一个范围的数据会受到影响，将影响降到了最小。

1. 当节点少时可能会导致节点在虚拟环上不均匀，造成数据倾斜。这时候可以通过计算多个节点的哈希值创建多个**虚拟节点**来均衡数据，理论上散列值越多数据分布越均匀。

判定哈希算法好坏的四个定义：
1. **平衡性**（Balance）：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。

1. **单调性**（Monotonicity）：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。

1. **分散性**（Spread）：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。

1. **负载**（Load）：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。


## 微服务
### 什么是微服务？微服务与分布式有什么区别？微服务有什么好处？

**微服务**：是指将一个大系统根据业务纵向拆分成多个功能相对独立的小系统，系统之间通过 http 或 RPC 相互调用，通过分布式来部署。

**分布式**：是指系统横向（集群）或纵向（微服务）拆分后的部署方式。

**好处**：

1. 降低耦合
1. 敏捷开发：不同业务由不同部门独立开发，降低了业务复杂度，降低了发布频率
1. 可以利用更多的硬件资源

### 从单体演化到微服务产生的问题？

1. 服务发现：本地方法调用变成远程服务调用，需要统一的服务发现机制。

1. 负载均衡：为了知道多节点如何选择，以及最大化资源利用率，最小化请求 RT，需要从节点池中选择出⼀个最佳的节点。

   * 硬件资源不同：硬件资源充足的节点设置更多权重
   * 地域不同：优先调用端近的地域
   * Session 等需要单调性的场景：Hash 保证每次访问同一个节点
   * 需要预热的节点：逐步引流

1. 熔断限流

1. 监控告警：统一的资源监控、告警系统

1. 认证鉴权

1. 链路追踪：服务调用节点每次是不一样的，分布式链路追踪

1. 日志收集：日志散落在各个节点：ELK