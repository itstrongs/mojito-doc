# Java 虚拟机

Java 虚拟机是运行 Java 代码的虚拟计算机规范，本质是一个程序，模拟了真实计算机的各种功能，比如堆栈、处理器、指令集...有不同的实现，目前使用最广泛的是 Hotspot VM，不同虚拟机实现垃圾回收、类加载等有所区别。

主要由字节码指令集、寄存器、垃圾收集器、堆、栈、方法区组成。

基本流程为：Java 代码通过编译器编译成 class 文件，然后通过类加载器加载 class 文件，最后通过解释器（或即时编译）执行。

<details>
<summary>推荐阅读<a href="http://cdn.liufq.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.pdf" target="_blank">《深入理解 Java 虚拟机》</a>，点击展开《深入理解 Java 虚拟机》思维导图。</summary>
<img src="http://cdn.liufq.com/FkDHQZG_RAMlvR1WXPzOVriX__BY"/>

第 3 章 垃圾收集器与内存分配策略
<img src="http://cdn.liufq.com/Funjq8P2lbA1o5rPzIfcxGHU6mGf"/>
</details>

## 类加载机制
### 类加载的过程（生命周期）？
1. **加载**：在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的数据入口；可以从 class 中加载、也可以从 jar 包、war 包、运行时生成（动态代理）、其他文件（比如 JSP ）生成；

1. **验证**：这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

1. **准备**：准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。

1. **解析**：解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。

1. **初始化**：初始化阶段是执行类构造器<client>方法的过程；如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>()方法。

### 类加载器有哪些？
类加载器的作用是把 class 文件装进虚拟机；分为系统类加载器和自定义类加载器，依次继承关系；

1. **启动类加载器**：负责加载 JAVA_HOME\lib 目录中的，或通过 -Xbootclasspath 参数指定路径中的，且被虚拟机认可的类。

1. **扩展类加载器**：负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。

1. **应用程序类加载器**：负责加载用户路径（classpath）上的类库，默认类加载器。

1. **自定义类加载器**：动态地创建符合用户特定需要的定制化构建类；从特定的场所取得 java class，例如数据库中和网络中；

### JVM 有哪些类加载机制？

1. **全盘负责**：当一个类加载器负责加载某个 Class 时，该 Class 所依赖的和引用的其他 Class 也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。

1. **缓存机制**：缓存机制将会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区寻找该 Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象，存入缓存区。这就是为什么修改了 Class 后，必须重启 JVM，程序的修改才会生效。

1. **双亲委派机制**：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

   双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载，也保证了 Java 的核心 API 不被篡改。

## Java 内存模型

### 程序计数器（PC 寄存器）
当前线程执行的字节码的行号指示器；唯一一个没有 OOM 的区域。

### 虚拟机栈

主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。

1. 每调用一个方法创建一个栈帧入栈，方法结束出栈，栈帧存储本地变量表、动态链接、方法出口等；
1. 可以通过参数 -Xss 来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。
1. 栈深度超过 JVM 允许的深度时抛出 StackOverflow；如果 JVM 允许动态扩展，申请不到足够内存时抛出 OutOfMemory；

### 本地方法栈
管理本地方法的调用，运行 Native 方法。与虚拟机栈类似。

### 方法区

方法区（method area）只是 JVM 规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT 编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而永久代（PermGen）是 Hotspot 虚拟机特有的概念， Java8 的时候又被元空间取代了，永久代和元空间都可以理解为方法区的落地实现。

JDK1.8 之前调节方法区大小：

```
# 方法区（永久代）初始大小
-XX:PermSize=N
# 方法区（永久代）最大大小，超出这个值将会抛出OutOfMemoryError
-XX:MaxPermSize=N
```

JDK1.8 开始方法区（HotSpot的永久代）被彻底删除了，取而代之的是元空间，元空间直接使用的是本机内存。参数设置：

```
# 设置Metaspace的初始（和最小大小）
-XX:MetaspaceSize=N
# 设置Metaspace的最大大小
-XX:MaxMetaspaceSize=N
```

**永久代和元空间内存使用上的差异**：Java 虚拟机规范中只定义了方法区用于存储已被虚拟机加载的类信息、常量、静态变量和即时编译后的代码等数据
1. jdk1.7 开始符号引用存储在 native heap 中，字符串常量和静态类型变量存储在普通的堆区中，但分离的并不彻底，此时永久代中还保存另一些与类的元数据无关的杂项
1. jdk8 后 HotSpot 原永久代中存储的类的元数据将存储在 metaspace 中，而类的静态变量和字符串常量将放在 Java 堆中，metaspace 是方法区的一种实现，只不过它使用的不是虚拟机内的内存，而是本地内存。在元空间中保存的数据比永久代中纯粹很多，就只是类的元数据，这些信息只对编译期或 JVM 的运行时有用。
1. 永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到 java.lang.OutOfMemoryError。
1. 符号引用没有存在元空间中，而是存在 native heap 中，这是两个方式和位置，不过都可以算作是本地内存，在虚拟机之外进行划分，没有设置限制参数时只受物理内存大小限制，即只有占满了操作系统可用内存后才 OOM。

### 堆内存
对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。

Java 虚拟机规范规定，Java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 -Xmx 和 -Xms 控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 OutOfMemoryError 异常。

为了进行高效的垃圾回收，通常把堆内存逻辑上分为新生代和老年代。

## 垃圾回收机制
### 垃圾回收过程
1. java 对象主要在堆上分配，当内存不足时触发 GC 回收，首先找出哪些对象需要回收，然后根据回收算法回收，一般通过分代回收或分区回收使用不同算法实现；

1. 可回收对象：通过引用计数法（有循环引用问题）或**可达性分析法**：如果一个对象没有和任何 GC Roots 建立引用，则认为是可回收对象，需要两次标记；

1. 分代回收：
   * 把堆内存分为新生代和老年代，新生代又分为 eden 区、from survivor 区、to survivor 区；
   * 新生代 GC 频率高、可回收对象多，一般采用复制算法，新创建的对象在 eden 区分配（大对象除外，直接分配在老年代），当 eden 区内存不足时找出 eden 区和 from 区存活对象复制到 to 区，然后清空 eden 区和 from 区，把 to 区作为新的 from 区，并把对象的年龄 +1；当对象年龄达到一定的值（默认15）移动到老年代；
   * 老年代 GC 频率低，可回收的对象少，一般采用标记整理算法；

1. 分区回收：将整个堆空间划分为连续的不同小区间，每个小区间独立使用独立回收，**好处**：可以控制一次回收多少个小区间, 根据目标停顿时间，每次合理地回收若干个小区间（而不是整个堆）, 从而**减少一次 GC 所产生的停顿**。

### GC Roots 有哪些？

1. 虚拟机栈中引用的对象
1. 方法区中类静态属性引用的对象
1. 方法区中常量引用的对象
1. 在本地方法栈中 JNI 引用的对象
1. JVM 内部的引用，比如基本数据类型对应的 Class 对象，一些异常对象，还有系统类加载器
1. 所有被 synchronized 持有的对象
1. 还有一些 JVM 内部的比如 JMXBean、JVMTI 中注册的回调，本地代码缓存等

### 有哪些常用垃圾收集器？
使用最广泛的 HotSpot VM 使用 CMS + ParNew 实现垃圾收集。所有收集器都是基于三种算法（复制、标记清除、标记整理）的组合或应用。

#### 1. Serial 收集器

Serial 翻译为串行，也就是说它以串行的方式执行。

它是单线程的收集器，只会使用一个线程进行垃圾收集工作。

它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。

它是 Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。

#### 2. ParNew 收集器

它是 Serial 收集器的多线程版本。

是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。

默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。

#### 3. Parallel Scavenge 收集器

与 ParNew 一样是多线程收集器。

其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为**吞吐量优先**收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: 新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。

可以通过一个开关参数打卡 GC 自适应的调节策略(GC Ergonomics)，就不需要手工指定新生代的大小(-Xmn)、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

#### 4. Serial Old 收集器

是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途:
* 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。
* 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

#### 5. Parallel Old 收集器

是 Parallel Scavenge 收集器的老年代版本。

在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

#### 6. CMS 收集器

CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。

分为以下四个流程:
1. **初始标记**: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。

1. **并发标记**: 进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
1. **重新标记**: 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
1. **并发清除**: 不需要停顿。

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

具有以下缺点:
1. **吞吐量低**: 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。

1. **无法处理浮动垃圾**：可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
1. **标记 - 清除算法导致的空间碎片**：往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

#### 7. G1 收集器
G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。

堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。

G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。

**通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收**。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤:

1. **初始标记**

1. **并发标记**
1. **最终标记**：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
1. **筛选回收**：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

具备如下特点:

1. **空间整合**: 整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。

1. **可预测的停顿**: 能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。

#### 8. 其他

* **ZGC**：JDK11 中推出的一款低延迟垃圾回收器，适用于大内存低延迟服务的内存管理和回收，SPECjbb 2015 基准测试，在 128G 的大堆下，最大停顿时间才 1.68 ms，停顿时间远胜于 G1 和 CMS。

* **Shenandoah**

### 什么是 Minor GC、Major GC、Full GC ？
JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。

针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：

* 部分收集（Partial GC）：不是完整收集整个 Java 堆的垃圾收集。其中又分为：

   1. 新生代收集（Minor GC / Young GC）：只是新生代的垃圾收集
   1. 老年代收集（Major GC / Old GC）：只是老年代的垃圾收集

      * 目前，只有 CMS GC 会有单独收集老年代的行为
      * 很多时候 Major GC 会和 Full GC  混合使用，需要具体分辨是老年代回收还是整堆回收
   1. 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集
      * 目前只有 G1 GC 会有这种行为
* 整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾

### JVM 内存分配策略
1. **对象优先在 Eden 分配**

1. **大对象直接进入老年代**：-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。

1. **长期存活的对象进入老年代**：-XX:MaxTenuringThreshold 用来定义年龄的阈值。

1. **动态对象年龄判定**：虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。

1. **空间分配担保**：在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。

   如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。

### 对象有哪些引用类型？
1. **强引用**：被强引用关联的对象不会被回收。

1. **软引用**：被软引用关联的对象只有在内存不够的情况下才会被回收。使用 SoftReference 类来创建软引用。

1. **弱引用**：被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用 WeakReference 类来实现弱引用。

1. **虚引用**：又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。使用 PhantomReference 来实现虚引用。

## JVM 调优
GC 调优目标：提高响应速度、提高吞吐量。

JVM 调优是指调节 JVM 参数，即对垃圾收集器和内存分配的调优，来达到**更高的吞吐和性能**。尽量减少 GC 的频率和 Full GC 的次数。

### 什么情况下会触发 Full GC ？

1. 调用 System.gc()

1. **老年代空间不足**：为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。

1. 空间分配担保失败

1. JDK 1.7 及以前的永久代空间不足

1. **Concurrent Mode Failure**：执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。

### JVM 调优方法和步骤？
1. **监控 GC 状态**：通过 JVM 工具、日志、当前参数、当前堆内存快照、gc 日志分析并优化

2. 生成并分析 dump 文件

3. 在测试机器上调整参数并不断尝试最合适的参数，应用到生产环境

### 调优原则
1. 更大的新生代必然导致更小的老年代；
2. 增大新生代会降低新生代 GC 频率，增加每次 GC 时间，导致老年代变小，导致 Full GC 更频繁；
2. 减低新生代会导致新生代 GC 更频繁以及更多的大对象直接分配到老年代，也可能导致 Full GC 更频繁；
3. 应该尽量降低 Full GC 频率，默认新生代老年代比率 1：2；
3. 线程堆栈大小可以适量降低，可以产生更多线程

## 参考
* [Java中9种常见的CMS GC问题分析与解决（上）](https://juejin.cn/post/6894500808583610382)

* [关于GC原理和性能调优实践，看这一篇就够了！
](https://juejin.cn/post/6844903953415536654)

* [JVM 面试题，安排上了！！！](https://juejin.cn/post/7016526088851423268)