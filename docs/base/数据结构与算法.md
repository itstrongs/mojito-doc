# 数据结构与算法

![](http://cdn.liufq.com/Fn4cPkGPyk6wxYt9BBF6r-dqwHMP)

## 数据结构
### 什么是堆？有哪些应用场景？
本质是一棵完全二叉树，每个节点的值比它左右孩子节点的值都小或者都大。比孩子节点值都大的叫**最大堆**，反之叫**最小堆**。

**应用场景**：
1. 堆排序
1. 生成优先级队列
1. 大数据量的计算 TopN 问题：找出大数据里最大的 K 个值，可以使用使用最小堆实现，最小堆堆顶存的时已有数据的最小值，当新来的值比已有的最小值还小时，不可能是最大的 K 个值之一，直接丢弃，否则移除一条堆数据加入新数据，遍历完后即得到 K 个最大值。

### 什么是二叉查找树？
BST（Binary Search Tree），也叫二叉搜索树、二叉排序树、有序二叉树，指一棵空树或者具有以下性质的二叉树：
1. 左子节点的值比父节点小
1. 右子节点的值比父节点大
1. 任意节点的左右子树也分别为二叉查找树
1. 没有键值相等的点

最坏的情况下会退化成链表，导致查询效率很低。主要**作用**：查找，时间复杂度 O(logN)；**缺点**：极度不平衡时最坏的情况 O(N)，因为这个缺点产生了平衡二叉树。

### 什么是平衡二叉树？
**二叉搜索树的查询效率取决于树的高度**，使用平衡二叉树的原因是为了降低树的高度。

增加删除元素时通过**自旋**实现树的重新平衡。可能需要多次自旋操作来重新平衡。

**最小失衡子树**：在新插入的结点向上查找，以第一个平衡因子的绝对值超过 1 的结点为根的子树称为最小不平衡子树。这个根节点为**失衡节点**。

**左旋**：当右子树高度和左子树高度差大于1时发生；(1)失衡节点右孩子替代此节点；(2)右孩子的左子树变成失衡节点的右子树；(3)失衡节点本身变成右孩子的左子树；

**右旋**：当左子树高度和右子树高度差大于1时发生；操作与左旋相反；

### 什么是 AVL 树？
强平衡二叉树，是平衡二叉树的具体实现方式，解决了二叉查找树退化成链表的问题，但增删过程的重平衡旋转比较耗时，不适合频繁更新。

1. 可以是空树。
2. 假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。

AVL 树的四种**节点插入方式**：
1. A的左孩子的左子树插入节点(LL)：只需要执行一次右旋即可。
2. A的右孩子的右子树插入节点(RR)：只需要执行一次左旋即可。
3. A的左孩子的右子树插入节点(LR)：两次自旋使原来根节点的左孩子的右孩子成为新的根节点，先让失衡节点的左节点进行左旋操作，再对失衡节点做右旋操作。
4. A的右孩子的左子树插入节点(RL)：与LR相反，两次自旋使原来失衡节点的右孩子的左孩子成为新的根节点，先让失衡节点的右节点进行右旋操作，在对失衡节点做左旋操作。

AVL 树的四种**节点删除方式**：

### 什么是红黑树（RBTree）？
弱平衡二叉树，相对 AVL 树旋转次数更少，增删查性能更好。但是大数据量时树的高度过高，导致 IO 次数过多，不适合大数据文件索引查找。AVL 是严格的平衡二叉树，插入删除的性能较差，实际使用更多用红黑树，性能更好。

1. 每个节点要么是黑的，要么是红的
1. 根节点是黑的
1. 叶节点是黑的
1. 如果一个节点是红的，他的两个儿子节点都是黑的
1. 对于任一节点而言，其到叶节点树尾端NIL指针的每一条路径都包含相同数目的黑节点

### 什么是满二叉树？
在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。

### 什么是完全二叉树？
对一颗具有n个结点的二叉树按层编号，如果编号为i(1<=i<=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。

## 算法

算法是实现某个或某类目的实现或思路。**基本思路**：把复杂问题分解成小问题（**分而治之**），**递归**所有可能，每次获取最优的解（**贪心算法**），对于可能的重复的子问题，用一个表储存之前所有解决过的子问题解（**动态规划**）。

### 什么是贪心算法？
对于一个较大的问题，通过找到与子问题的重叠，把复杂的问题划分成小问题，找到每个子问题的最优解，再合成全局最优解。

1. 建立数学模型来描述问题
2. 把求解的问题分成若干个子问题
3. 对每个子问题求解，得到子问题的局部最优解
4. 把子问题的最优解合成为原来问题的解

### 什么是动态规划？

1. 直接思考最后一步怎么得到的，再把复杂问题分解成子问题
2. 把每一步子问题写成转移方程，通过数组存储
3. 处理初始情况和边界情况，迭代计算

### 什么是深度、广度优先搜索 / 遍历？

1. **深度优先遍历**（DFS）：从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树节点的遍历，直到遍历完所有可达节点为止。**实现**：父节点入栈，父节点出栈，先右子节点入栈，后左子节点入栈。递归遍历全部节点。

2. **广度优先遍历**（BFS）：从根节点出发，在横向遍历二叉树层段节点的基础上纵向遍历二叉树的层次。**实现**：父节点入队，父节点出队列，先左子节点入队，后右子节点入队。递归遍历全部节点。

## 十大排序算法

![](http://cdn.liufq.com/5c5aad3b474e435d83bb954f95a29594_tplv-k3u1fbpfcp-watermark.png)

**排序算法选择**：元素为基本数据类型使用快速排序；元素为自定义数据类型使用归并排序；样本数量小使用插入排序；样本数量大先使用快速排序或归并排序削减规模，后使用插入排序。

**稳定性**：是指数组中相同元素在排序前后的相对次序是否保持不变。

### 冒泡排序
循环N - 1次，每次通过相邻元素比较交换将最大值移到最后。

```
public void bubbleSort(int[] data) {
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = 0; j < data.length - 1 - i; j++) {
            if (data[j] > data[j + 1]) {
                swap(data, j, j + 1);
            }
        }
    }
}
```

### 选择排序
循环N - 1次，每次从剩余未排序的数据中找到最小的值和已排序后一个值交换。

和冒泡类似，区别在于不用每次都交换，找到最大值记录位置，一次交换

```
public void selectionSort(int[] data) {
    for (int i = 0; i < data.length - 1; i++) {
        int min = i;
        for (int j = i + 1; j < data.length; j++) {
            if (data[j] < data[min]) {
                // 记录目前能找到的最小值元素的下标
                min = j;
            }
        }
        // 将找到的最小值和i位置所在的值进行交换
        if (i != min) {
            swap(data, i, min);
        }
    }
}
```

### 插入排序
循环N - 1次，每次从未排序数据中取出一个插入到已排序列表，从后往前比较，比插入值大的往后移，直到找到比它小的值后，赋值到空出的位置。

每次认为第一个有序，然后循环把后面的数据插入有序位置，通过不断跟有序数据比较交换实现。

**优点**：对基本有序的数据效率高。

```
public void insertSort(int[] data) {
    // 从下标为 1 的元素开始选择合适的位置插入，因为下标为 0 的只有一个元素，默认是有序的
    for (int i = 1; i < data.length; i++) {
        // 记录要插入的数据
        int tmp = data[i];
        // 从已经排序的序列最右边的开始比较，找到比其小的数
        int j = i;
        while (j > 0 && tmp < data[j - 1]) {
            data[j] = data[j - 1];
            j--;
        }
        // 存在比其小的数，插入
        if (j != i) {
            data[j] = tmp;
        }
    }
}
```

### 快速排序
1. 通过设置一个基准值，找到这个基准值的一个位置，使得这个位置左边的值都比基准值小，右边的值都比基准值大；
1. 然后根据这个位置把数据拆成两段，分别递归执行上一步。

```
public int[] quickSort(int[] arr, int left, int right) {
    if (left < right) {
        int partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex - 1);
        quickSort(arr, partitionIndex + 1, right);
    }
    return arr;
}

private int partition(int[] arr, int left, int right) {
    // 基准值，一般把第一个值作为基准值
    int pivot = left;
    // 基准值要放的位置，核心就是要找到这个位置，这个位置应该等于比基准值小的数的个数
    // 这个位置把数组拆成 2 段，每段再递归执行相同逻辑
    int index = pivot + 1;
    for (int i = index; i <= right; i++) {
        if (arr[i] < arr[pivot]) {
            // 找到比基准值小的数据后，交换当前数据和基准值位置数据
            swap(arr, i, index);
            // 每找到一个比基准值小的数据，基准值要放的位置就加 1
            index++;
        }
    }
    // 最后把基准值放到找到的位置
    swap(arr, pivot, index - 1);
    return index - 1;
}
```

### 什么是布隆过滤器？

**原理**：
1. 首先初始化一个二进制数组，长度为L，初始值都为0；
2. 每次写入数据对数据进行H次hash运算，结果对L取模后定位到H个点，置为1；
3. 判断一个数是否存在时，也对它进行H次hash运算并取模，只要有一个值为0，则认为一定不存在，都为1认为非常大概率存在；

**特点**：
1. 有一定误报率，存在hash冲突，可以降得很低；
2. 可以精确判断不存在；
3. 不可能删除加入的数据；

## 面试常见算法题

### 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词?

**分而治之/hash映射**: 顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件(记为x0,x1,...x4999)中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。

**hash_map统计**: 对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。

**堆/归并排序**: 取出出现频率最大的100个词(可以用含100个结点的最小堆)后，再把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并(类似于归并排序)的过程了。

## 参考
* [图解红黑树](https://juejin.cn/post/6844903511893737486)

* [什么是平衡二叉树（AVL） - 程序员吴师兄的文章 - 知乎](https://zhuanlan.zhihu.com/p/56066942)

* [十大排序算法串讲](https://juejin.cn/post/6897582526102798343#heading-6)