# 操作系统

## Linux IO 模型
### 什么是 IO ？
网络通讯流程：A 应用给 B 应用发消息，A 应用先把消息发送到 A 服务的 TCP 发送缓存区，然后通过网络把数据发到 B 应用所在服务器的 TCP 接收缓冲区，B 应用再从接收缓冲区读取属于自己的数据。

IO 就是指发送数据到缓冲区和读取缓冲区数据。

Linux 系统把所有网络请求以一个 `fd`【文件描述符】 来标识。

### 什么是阻塞？什么是同步？
**阻塞**是程序级别的，主要描述的是程序请求操作系统 IO 操作后，如果 IO 资源没有准备好，那么程序该如何处理的问题: 阻塞 IO 等待；非阻塞 IO 继续执行(并且使用线程一直轮询，直到有 IO 资源准备好了)

**同步**是操作系统级别的。主要描述的是操作系统在收到程序请求 IO 操作后，如果 IO 资源没有准备好，该如何响应程序的问题: 同步 IO 不响应，直到 IO 资源准备好以后；非同步 IO 返回一个标记(好让程序和自己知道以后的数据往哪里通知)，当 IO 资源准备好以后，再用事件机制返回给程序。

### Linux IO 模型有哪些？

网络 IO 的本质是 socket 的读取，socket 在 linux 系统被抽象为流，IO 可以理解为对流的操作。对于一次 IO 访问（以 read 举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个 read 操作发生时，它会经历两个阶段：
1. 第一阶段：等待数据准备 (Waiting for the data to be ready)。
1. 第二阶段：将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)。

对于socket流而言，
1. 第一步：通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。
1. 第二步：把数据从内核缓冲区复制到应用进程缓冲区。

#### 1. 同步阻塞 IO
发起一次 IO 操作后一直等待成功或失败之后才返回，只能对单个文件描述符进行操作。应用调用 recvfrom 读取数据时，数据到达缓冲区或发生错误时返回，否则一直阻塞等待。

主线程阻塞 + 线程池模型，主线程死循环等待新连接，为新连接建立新线程。

#### 2. 同步非阻塞 IO

与阻塞 IO 类似，也是只能对单个文件描述符轮训进行操作，但是当需要阻塞时直接返回错误。

#### 3. IO 多路复用

单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力。多路指检测多个文件描述符，复用指同一个线程。linux 提供了 3 种方式。

* **select**：它仅仅知道有 IO 发生了，却并不知道哪几个流，只能无差别轮训所有流，找出能读出数据或写入数据的流进行操作，o(n) 复杂度。

* **poll**：poll 本质上和 select 没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个 fd 对应的设备状态，但是它没有最大连接数的限制，原因是它是基于链表来存储的。

* **epoll**：epoll 可以理解为 event poll，不同于忙轮询和无差别轮询，epoll 会把哪个流发生了怎样的 I/O 事件通知我们。所以我们说 epoll 实际上是事件驱动（每个事件关联上fd）的，复杂度降低到了 O(1)。

#### 4. 信号驱动 IO

   IO 复用模型采用轮训的方式监控多个 fd，轮训很多时候是无效的，而信号驱动 IO 模型是数据准备好后通知我。

   首先开启套接口信号驱动IO功能，并通过系统调用sigaction执行一个信号处理函数，此时请求即刻返回，当数据准备就绪时，就生成对应进程的SIGIO信号，通过信号回调通知应用线程调用recvfrom来读取数据。

#### 5. 异步 IO

前 4 种都是同步 IO。

应用告知内核启动某个操作，并让内核在整个操作完成之后，通知应用，这种模型与信号驱动模型的主要区别在于，信号驱动IO只是由内核通知我们合适可以开始下一个IO操作，而异步IO模型是由内核通知我们操作什么时候完成。

`同步 IO 与异步 IO 区别`：在IO模型里面如果请求方从发起请求到数据最后完成的这一段过程中都需要自己参与，那么这种我们称为同步请求；反之，如果应用发送完指令后就不再参与过程了，只需要等待最终完成结果的通知，那么这就属于异步。