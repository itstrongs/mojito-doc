# 计算机网络

## NAT 与 FRP
局域网通过路由器使用 NAT（网络地址转换）技术把多台主机转换成同一个公网 IP，以此达到一个公网 IP 可以让多台主机上网的目的。

这个过程访问是单向的，路由器充当了一个正向代理作用，客户机能访问外网机，外网机不能访问客户机，那怎么让外网机访问客户机呢？

可以通过**内网穿透**实现，FRP 是一种实现方案。

**基本原理**：通过在内网机和公网机上分别部署程序，启动后建立长连接，第三方用户访问的时候公网机把数据通过长连接转发给内网机，从而现实第三方用户和内网机的连通。

## 网络模型
### OSI 七层协议模型
两个终端应用交换数据，把网页、图片等数据通过多层协议解析成不同数据形式（段、报文、帧、字节）发送，再通过相反的过程还原数据的过程；

* **物理层**：定义物理设备标准；传输比特流（把 0、1 转化成电流强弱来传输，即模数转换）；数据是比特；

* **数据链路层**：把物理层接收的数据进行 Mac 地址的封装；工作设备是交换机；数据通常叫帧；
* **网络层**：主要将链路层接收的数据进行 IP 地址封装；工作设备是路由器；数据通常叫数据包；
* **传输层**：定义了传输数据的协议和端口号，比如 TCP、UDP；主要是将从下层接收到的数据分段进行传输；数据通常叫段；
* **会话层**：通过传输层建立数据传输的通路；主要在系统中发起会话和接受会话请求；
* **表示层**：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等））；
* **应用层**：主要是一些终端的应用，比如说 FTP、WEB 浏览器；

### TCP / IP 四层协议模型
TCP / IP 协议不是 TCP 和 IP 这两个协议的合称，而是指因特网整个 TCP / IP 协议族。

* **网络访问层**：主机必须使用某种协议与网络相连；

* **网络层**：使主机可以把分组发往任何网络，并使分组独立地传向目标；使用 IP 协议；
* **传输层**：使源端和目的端机器上的对等实体可以进行会话；分为 TCP、UDP 协议；
* **应用层**：包含所有的高层协议，比如：FTP、DNS、SMTP、HTTP...

## 网络协议

### TCP 三次握手

TCP 在建立连接的过程中，为了保证数据能到达目标，采用了三次握手策略。

TCP 有 6 种标识：SYN（建立联机）、ACK（确认）、PSH（传送）、FIN（结束）、RST（重置）、URG（紧急）。

#### 1. 什么是三次握手？

1. 发送端首先发送一个带 SYN（synchronize）标志的数据包给接收方（第一次的 seq 序列号是随机产生的，这样是为了网络安全，如果不是随机产生初始序列号，黑客将会以很容易的方式获取到你与其他主机之间的初始化序列号，并且伪造序列号进行攻击）
1. 接收端收到后，回传一个带有 SYN / ACK（acknowledgement）标志的数据包以示传达确认信息（SYN 是为了告诉发送端，发送方到接收方的通道没问题；ACK 用来验证接收方到发送方的通道没问题）
1. 最后，发送端再回传一个带 ACK 标志的数据包，代表握手结束。若在握手某个过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包

#### 2. 为什么要三次握手？

三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。

1. 第一次握手，发送端：什么都确认不了；接收端：对方发送正常，自己接受正常
1. 第二次握手，发送端：对方发送，接受正常，自己发送，接受正常 ；接收端：对方发送正常，自己接受正常
1. 第三次握手，发送端：对方发送，接受正常，自己发送，接受正常；接收端：对方发送，接受正常，自己发送，接受正常

#### 3. 两次握手不行吗？为什么 TCP 客户端最后还要发送一次确认呢？
主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。经典场景：客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了。
1. 由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。
1. 此时此前滞留的那一次请求连接，网络通畅了到达服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。
1. 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

#### 4. 为什么三次握手返回时，ack 值是 seq 加 1（ack = x + 1）？
1. 假设对方接收到数据，比如 sequence number = 1000，TCP Payload = 1000，数据第一个字节编号为 1000，最后一个为 1999，回应一个确认报文，确认号为 2000，意味着编号 2000 前的字节接收完成，准备接收编号为 2000 及更多的数据
1. 确认收到的序列，并且告诉发送端下一次发送的序列号从哪里开始（便于接收方对数据排序，便于选择重传）

#### 5. TCP三次握手中，最后一次回复丢失，会发生什么？
1. 如果最后一次 ACK 在网络中丢失，那么 Server 端（服务端）该 TCP 连接的状态仍为 SYN_RECV，并且根据 TCP 的超时重传机制依次等待 3 秒、6 秒、12 秒后重新发送 SYN + ACK 包，以便 Client（客户端）重新发送 ACK 包
1. 如果重发指定次数后，仍然未收到 ACK 应答，那么一段时间后，Server（服务端）自动关闭这个连接
1. 但是 Client（客户端）认为这个连接已经建立，如果 Client（客户端）端向 Server（服务端）发送数据，Server 端（服务端）将以 RST 包（Reset，标示复位，用于异常的关闭连接）响应，此时，客户端知道第三次握手失败

### TCP 断开连接的四次挥手

#### 1. 什么是四次挥手？

1. 主动断开方（客户端/服务端）：发送一个 FIN，用来关闭主动断开方（客户端/服务端）到被动断开方（客户端/服务端）的数据传送
1. 被动断开方（客户端/服务端）：收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号
1. 被动断开方（客户端/服务端）：关闭与主动断开方（客户端/服务端）的连接，发送一个 FIN 给主动断开方（客户端/服务端）
1. 主动断开方（客户端/服务端）：发回 ACK 报文确认，并将确认序号设置为收到序号加 1

#### 2. 为什么连接的时候是三次握手，关闭的时候却是四次握手？
1. 建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。
1. 关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了,所以服务器可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接。因此，服务器 ACK 和 FIN 一般都会分开发送，从而导致多了一次。

### TCP 和 UDP 有什么区别 ？

| | UDP | TCP |
| --- | -- | --- |
| 是否连接 | 无连接 | 面向连接 |
| 是否可靠 | 不可靠传输，不使用流量控制和拥塞控制 | 可靠传输，使用流量控制和拥塞控制 |
| 连接对象个数| 支持一对一，一对多，多对一和多对多交互通信| 只能是一对一通信|
| 传输方式| 面向报文| 面向字节流|
| 首部开销| 首部开销小，仅 8 字节| 首部最小 20 字节，最大 60 字节|
| 适用场景| 适用于实时应用（IP 电话、视频会议、直播等）| 适用于要求可靠传输的应用，例如文件传输|

**总结**：

1. TCP 向上层提供面向连接的可靠服务 ，UDP 向上层提供无连接不可靠服务
1. 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为
1. 对数据准确性要求高，速度可以相对较慢的，可以选用 TCP

### HTTP 和 HTTPS 有什么区别 ？

HTTP 是**超文本传输协议**（Hypertext Transfer Protocol）协议，它是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。

HTTP 是**不安全的**，HTTP 在传输过程中不会验证通信方的身份，因此 HTTP 信息交换的双方可能会遭到伪装，也就是**没有用户验证**；在 HTTP 的传输过程中，接收方和发送方并**不会验证报文的完整性**。

HTTPS 解决了 HTTP 的这些问题。

HTTPS 是安全的 HTTP 协议，是在 HTTP 的基础上，使用传输层安全性（TLS）或安全套接字层（SSL）对通信协议进行加密。也就是 HTTP + SSL(TLS) = HTTPS。

1. **加密**：第三方截获数据无法知道明文是什么

1. **完整性验证**：第三方篡改数据，会使得数据变得无效

1. **身份认证**：交流双方可以确认对方的身份，第三方无法伪装成任何一方进行交流

**HTTPS 执行流程**：

1. 用户在浏览器发起 HTTPS 请求，默认使用服务端的 443 端口进行连接；
1. HTTPS 需要使用一套 CA 数字证书，证书内会附带一个公钥 Pub，而与之对应的私钥 Private 保留在服务端不公开；
1. 服务端收到请求，返回配置好的包含公钥 Pub 的证书给客户端；
1. 客户端收到证书，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示 HTTPS 警告信息，如果通过则继续；
1. 客户端生成一个用于对称加密的随机 Key，并用证书内的公钥 Pub 进行加密，发送给服务端；
1. 服务端收到随机 Key 的密文，使用与公钥 Pub 配对的私钥 Private 进行解密，得到客户端真正想发送的随机 Key；
1. 服务端使用客户端发送过来的随机 Key 对要传输的 HTTP 数据进行对称加密，将密文返回客户端；
1. 客户端使用随机 Key 对称解密密文，得到 HTTP 数据明文；
1. 后续 HTTPS 请求使用之前交换好的随机 Key 进行对称加解密。

## DNS 与网络安全
### DNS 解析流程？

一般完成前 4 步就能完成解析。

1. 本地客户机提出域名解析请求，查找本地 HOST 文件后将该请求发送给本地的域名服务器。
1. 将请求发送给本地的域名服务器。
1. 当本地的域名服务器收到请求后，就先查询本地的缓存。
1. 如果有该纪录项，则本地的域名服务器就直接把查询的结果返回浏览器。
1. 如果本地 DNS 缓存中没有该纪录，则本地域名服务器就直接把请求发给根域名服务器。
1. 然后根域名服务器再返回给本地域名服务器一个所查询域（根的子域）的主域名服务器的地址。
1. 本地服务器再向上一步返回的域名服务器发送请求，然后接受请求的服务器查询自己的缓存，如果没有该纪录，则返回相关的下级的域名服务器的地址。
1. 重复第 7 步，直到找到正确的纪录。
1. 本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时还将结果返回给客户机。

### 为什么 DNS 通常基于 UDP ？
DNS 通常是基于 UDP 的，但当数据长度大于 512 字节的时候，为了保证传输质量，就会使用基于 TCP 的实现方式。

* **从数据包的数量以及占有网络资源的层面**：使用基于 UDP 的 DNS 协议只要一个请求、一个应答就好了; 而使用基于 TCP 的 DNS 协议要三次握手、发送数据以及应答、四次挥手；明显基于 TCP 协议的 DNS 更浪费网络资源！

* **从数据一致性层面**：DNS 数据包不是那种大数据包，所以使用 UDP 不需要考虑分包，如果丢包那么就是全部丢包，如果收到了数据，那就是收到了全部数据！所以只需要考虑丢包的情况，那就算是丢包了，重新请求一次就好了。而且 DNS 的报文允许填入序号字段，对于请求报文和其对应的应答报文，这个字段是相同的，通过它可以区分 DNS 应答是对应的哪个请求

### 什么是 DNS 劫持？

DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。

### 什么是 DNS 污染？
DNS 污染是一种让一般用户由于得到虚假目标主机 IP 而不能与其通信的方法，是一种 DNS 缓存投毒攻击（DNS cache poisoning）。其工作方式是：由于通常的 DNS 查询没有任何认证机制，而且 DNS 查询通常基于的 UDP 是无连接不可靠的协议，因此 DNS 的查询非常容易被篡改，通过对 UDP 端口 53 上的 DNS 查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。

而 DNS 污染则是发生在用户请求的第一步上，直接从协议上对用户的 DNS 请求进行干扰。

#### 1. DNS 污染症状：
目前一些被禁止访问的网站很多就是通过 DNS 污染来实现的，例如 YouTube、Facebook 等网站。

#### 2. 解决方法:
1. 对于 DNS 劫持，可以采用使用国外免费公用的 DNS 服务器解决。例如 OpenDNS（208.67.222.222）或 GoogleDNS（8.8.8.8）。
1. 对于 DNS 污染，可以说，个人用户很难单单靠设置解决，通常可以使用 VPN 或者域名远程解析的方法解决，但这大多需要购买付费的 VPN 或 SSH 等，也可以通过修改 Hosts 的方法，手动设置域名正确的 IP 地址。

### 什么是 SYN 洪泛攻击？

SYN Flood利用TCP协议缺陷，发送大量伪造的TCP连接请求，常用假冒的IP或IP号段发来海量的请求连接的第一个握手包（SYN包），被攻击服务器回应第二个握手包（SYN+ACK包），因为对方是假冒IP，对方永远收不到包且不会回应第三个握手包。导致被攻击服务器保持大量SYN_RECV状态的“半连接”，并且会重试默认5次回应第二个握手包，大量随机的恶意syn占满了未完成连接队列，导致正常合法的syn排不上队列，让正常的业务请求连接不进来。【服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击】

SYN 攻击不能完全被阻止，除非将 TCP 协议重新设计。我们所做的是尽可能的减轻 SYN 攻击的危害。